明示してなければたぶん 1.8.7 / 1.9.2 で動作するはず。

Rails については [[Rails tips]] 参照。

= String#inspect で16進数表記を返す =
バイナリを扱うプログラムの開発時などに。16バイト毎に改行します。
<source lang="ruby">
class String
  def inspect
    s, l = '', ''
    self.each_byte do |b|
      l << b.to_s(16).upcase.rjust(2, '0') + ' '
      if l.size >= 16 * 3
        s << l.strip + "\n"
        l = ''
      end
    end
    s << l.strip if l != ''
    s
  end
end
</source>
<source lang="ruby">
# Usage
p 'labocho' #=> 6C 61 62 6F 63 68 6F
</source>

= Base64 エンコード / デコード =
エンコード
<source lang="ruby">
# Base64 Encoder
# Usage: ruby base64_encoder.rb binary_file
print [ARGF.binmode.read].pack("m").gsub(/[\r\n]/, '')
</source>
デコード
<source lang="ruby">
# Base64 Decoder
# Usage: ruby base64_decoder.rb base64_file
STDOUT.binmode.print ARGF.binmode.read.unpack("m")[0]
</source>
IO#binmode は Windows 環境で必要 (別の環境では無視される)。

= 定数の探索 =
モジュール / クラス内の定数 (もちろんモジュール / クラスも含む) を、外側のモジュール / クラス名::定数名 で参照できる。クラスの定義 / オープン時にもこの記法は使えるが、素朴に module / class 文をネストした場合と定数の探索範囲が異なる。

モジュールを名前空間として使う場合、同じ名前空間内のクラスを参照するときに名前空間名を省略したいので、module / class 文のネストに統一したほうがよさそう。

<source lang="ruby">
# モジュールで定数を定義
module M
  MODULE_CONSTANT = "MODULE_CONSTANT"
end

# ネストして記述した場合、外側のモジュール / クラスの定数が探索される
module M
  class C
    puts MODULE_CONSTANT # MODULE_CONSTANT
  end
end

# ::で記述した場合、外側のモジュール / クラスの定数が探索されない
class M::C
  puts MODULE_CONSTANT # NameError: uninitialized constant M::C::MODULE_CONSTANT
end
</source>

Ruby リファレンスマニュアルの記述を参照すると、定数の探索は次の順で行われる。

# そのモジュール / クラス
# ネストしていれば外側のモジュール / クラス
# 継承元のクラスを近い方から

トップレベルで定義した定数は Object クラスに属するので、3 の最後に探索される。
2 の「ネストしていれば」は、定数を参照するときのコンテキストが module / class 文でネストしていれば、の意味。定数の定義時は module / class 文でネストしていようが、:: を使っていようが関係ない。

= false をとりうる変数と nil ゲートに関する注意 =
a ||= b や a = b if b のような、nil ゲートはよく使うイディオムだが、false をとりうる変数について使用する際には注意が必要。

<source lang="ruby">
class Unexpected1
  attr_writer :flag

  def flag
    return @flag ||= true
  end
end

u = Unexpected1.new
u.flag # => true
u.flag = false
u.flag # => true
</source>

ここでは @flag が設定されていなければ (nil なら) true をセットして返すことを想定しているが、flag= で false を代入しても、@flag は falsy であるため、再度 true をセットして返してしまう。

<source lang="ruby">
return @flag.nil? ? (@flag = true) : @flag
</source>

のように明確に nil かどうかをみる必要がある。

<source lang="ruby">
class Unexpected2
  attr_accessor :flag
	
  def initialize
    @flag = true
  end

  def set(hash)
    @flag = hash[:flag] if hash[:flag]
  end
end

u = Unexpected2.new
u.flag # => true
u.set(:flag => false)
u.flag # => true
</source>

ここでは、hash[:flag] があれば (nil でなければ) @flag にセットしているが、hash[:flag] が false なら if 節は成立しないため、@flag に false がセットされることはない。

<source lang="ruby">
@flag = hash[:flag] if hash.has_key?(:flag)
</source>

のように、明確にそのキーの値があるかを調べた方がよい (この方法なら nil が指定されていても調べられる)。

= 本 =
<amazon locale="jp" id="4873113679">
== %title% ==
プログラマのための Ruby 入門。簡潔で正確。この本を読めばリファレンスマニュアルが理解できるようになり、かなりのことができるようになる。最初にこの本を読んでよかった。

[%url% %mediumimage%]

[%url% %title% / %author% 著. %publisher%, %publishedyear%, %pages%p.]
</amazon>

<amazon locale="jp" id="4048687158">
== %title% ==
マニアックに見えるが、Ruby をちゃんと使うためには必須と思える内容。Ruby におけるクラス/モジュールとはどんなものなのか、特異メソッド/クラスとはなんなのか、Rails の魔法はどのようにできているのかが理解できる。抽象的な概念も順を追ってやさしく解説してくれる。

[%url% %mediumimage%]

[%url% %title% / %author% 著. %publisher%, %publishedyear%, %pages%p.]
</amazon>